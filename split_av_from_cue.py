#!/usr/bin/env python
#
# Given CUE file, uses FFMPEG to extract tracks from AV file (eg. mp3, 
# wav, flac, etc.). Input AV must be ffmpeg compatible format.
#
# INPUT
# ----------------
# Use '--help' to get descrption on input parameters.
#
# "path.txt" - File in the same directory this .py file is in, if exists, 
#              first line path is added to the PATH environment variable.
#              If it is a path to existing file, it is assumed to be ffmpeg 
#              executable itself, and is used.
#
#
import os, sys, optparse, time, datetime
import re   ## Regex
import subprocess

szHxIcue = "CUE file either as (1) '--icue FILE' or (2) as first loose file with cue extension."
szHxOdn = "Optional output directory either as (1) '--odn DIR' or (2) autogenerated from CUE location + timestamp subdir (uses 'mkdir')."
szHxImf = "Media file either as (1) '--imf FILE', (2) first loose non cue file or (3) entry named 'FILE' found in cue file."

print("")
reQtdStr = re.compile("\\x22(.*?)\\x22")
g1z      = type("", (), {"group": (lambda self,g: ""),} )()
bAutoOud = 0
szFfe    = "ffmpeg"

szPathTxtFn = ("%s/path.txt" % (os.path.dirname(__file__),))
if( os.path.isfile(szPathTxtFn) ):
	ln0 = os.path.expandvars( open(szPathTxtFn).read(1024).splitlines()[0].strip() )
	if( os.path.isfile(ln0) ):
		szFfe = ln0
	elif len(ln0):
		os.environ["PATH"] = ( "%s%s%s" % (ln0, os.pathsep, os.getenv("PATH"),) )

szStd = subprocess.check_output( ("%s -version" % (szFfe,)), shell=True )
s = ( ( re.search("ffmpeg \\s+ version \\s+ ([^\\s]+)", szStd, re.I|re.X ) or g1z ).group(1) )
print("Using FFMPEG version: [%s]" % (s,) )

if( not len(s) ):
	print("ERROR: no working ffmpeg executable found.")
	print("       [%s]" % (szFfe,) )
	sys.exit(3)


prsr = optparse.OptionParser()
prsr.add_option("--icue", dest="icue", help=szHxIcue )
prsr.add_option("--imf", dest="imf", help=szHxImf )
prsr.add_option("--odn", dest="odn", help=szHxOdn )
prsr.add_option("--no_cli_menu", dest="no_cli_menu", help="" )
(optns, args) = prsr.parse_args()

szCue = ( optns.icue if optns.icue else "" )
szImf = ( optns.imf  if optns.imf  else "" )
szOud = ( optns.odn  if optns.odn  else "" )
bCliMenu = ( 0 if int(bool(optns.no_cli_menu)) else 1 )

for a in args:
	ext2 = (os.path.splitext(a)[1]).strip(".").lower()
	if( ext2 == "cue" ):
		if( not len(szCue) ):
			szCue = a
	elif( not len(szImf) ):
		szImf = a
	
if( not szCue ):
	print("ERROR: no input CUE file (see '--icue FILE').")
	sys.exit(2)
if( not os.path.isfile(szCue) ):
	print("ERROR: CUE file not found.")
	sys.exit(2)
if( not szOud ):
	ts2 = int(round(time.time() * 1000)) / 1000
	bAutoOud = 1
	szOud = ("%s/out_%X" % ( os.path.dirname(szCue), ts2,) )
	print("INFO: autogenerated output directory to sub-dir-timestamp of the CUE file.")
	print("      [...%s]" % (szOud[-32:],) )
if( (not bAutoOud) and (not os.path.isdir(szOud)) ):
	print("ERROR: output dir not found.")
	sys.exit(2)
	
print("Parsing CUE file...")
lines2 = open(szCue).read().splitlines()
print("Num lines: %d" % (len(lines2),) )
tracks2 = []; nErr = 0
if 1:
	trk = {}; nTrcks = 0
	for i in range(0, len(lines2) ):
		ln2 = lines2[i].strip()
		if( i==0 and ln2.find("\xEF\xBB\xBF") == 0 ):   ## UTF-8 BON check.
			ln2 = ln2[3:]
		if( not len(szImf) and ln2.find("FILE") == 0 ):     ## FILE "a.mp3" MP3
			s = ( ( reQtdStr.search(ln2) or g1z ).group(1) )
			if( not len(s) ):    ## 0x22=dbl-quote, 0x27=single-quote.
				s = ( ( re.search("FILE\\s+([^\\s\\x22]+)", ln2) or g1z ).group(1) )
			szImf = ( s if s else szImf )
			if( not os.path.isabs(szImf) and len(szCue) ):
				print("INFO: prefixing AV file path from CUE with dir-name of the CUE file.")
				szImf = ("%s/%s" % (os.path.dirname(szCue), szImf,))
		elif( ln2.find("TRACK") == 0 ):
			if( len(trk) ):
				tracks2 += [trk.copy(),]
			trk.clear()
			nTrcks += 1
		if nTrcks:
			if( ln2.find("TITLE") == 0 ):
				s = ( ( reQtdStr.search(ln2) or g1z ).group(1) )
				trk["ttl"] = s
			elif( (ln2.find("PERFORMER") == 0) or (ln2.find("AUTHOR") == 0) ):
				s = ( ( reQtdStr.search(ln2) or g1z ).group(1) )
				trk["ath"] = s
			elif( ln2.find("INDEX") == 0 ):    ## INDEX 01 06:03:00
				mt3 = re.search("(\\d+):(\\d+):(\\d+)", ln2, re.I|re.X )   ## format is: mins:secs:ms
				if mt3:
					trk["tm2"] = mt3.group(0)
					trk["tm3"] = [ mt3.group(1), mt3.group(2), mt3.group(3), ]
					trk["tm4"] = map( (lambda a: int(a)), trk["tm3"] )
				else:
					print("ERROR: bad time format of the 'INDEX' at line: %d." % (i,) )
					nErr += 1
	if( len(trk) ):
		tracks2 += [trk.copy(),]
		trk.clear()
	del trk; del nTrcks; del i

print("")
print("Input CUE : [...%s]" % (szCue[-46:],) )
print("Input AV  : [...%s]" % (szImf[-46:],) )
print("Output dir: [...%s]" % (szOud[-46:],) )

if( not szImf ):
	print("ERROR: no input AV file (see '--imf FILE').")
	sys.exit(2)

tracks3 = []
for i in range(0, len(tracks2)):
	a = tracks2[i]
	n = ( tracks2[i+1] if ( i+1 < len(tracks2) ) else None )
	tm4   = a["tm4"]; len2 = None
	tdBgn = datetime.timedelta( minutes = tm4[0], seconds = tm4[1], milliseconds = tm4[2] )
	bgn2  = tdBgn.total_seconds()
	if n:
		tm5 = n["tm4"]
		tdEnd = datetime.timedelta( minutes = tm5[0], seconds = tm5[1], milliseconds = tm5[2] )
		len2 = (tdEnd - tdBgn).total_seconds()
	tracks3 += [{"bgn": a["tm2"], "bgn2": bgn2, "len2": len2, "ath":a["ath"], "ttl":a["ttl"],}]

print("\n"+"Preview:")
for i in range(0, len(tracks3)):
	a = tracks3[i]
	bOk = ( 1 if (not i) else ( 1 if (i+2 >= len(tracks3)) else 0 ) )
	if bOk:
		print("%5s: [%8s], bgn:[%-9s], len:[%-9s]" % 
				( ("First" if (not i) else ("#%02d"%(i+1,)) ), 
						a["bgn"], str(a["bgn2"]), str(a["len2"]),) )
ans2 = ""
if bCliMenu:
	print("")
	print("--- Menu ---")
	print("b    --  hide ffmpeg stdout.")   ##bNoFfmStdou
	print("c    --  strip metadata.")   ##bStripMetadata
	print("d    --  stop on ffmpeg errors.")   ##bStopOnFfErr
	print("e    --  wait for confirm after each item.")   ##bCnfrmWaitNext
	print("f    --  no author and title for output file names.")   ##bNoAuthTitile
	print("[xx] --  output format extension, otherwise input ext is used (eg. [mp3]).")   ##szNewFmt
	print("Selection:")
	ans2 = raw_input()

bNoFfmStdou    = ( 1 if ( 1+ans2.find("b") ) else 0 )
bStripMetadata = ( 1 if ( 1+ans2.find("c") ) else 0 )
bStopOnFfErr   = ( 1 if ( 1+ans2.find("d") ) else 0 )
bCnfrmWaitNext = ( 1 if ( 1+ans2.find("e") ) else 0 )
szNewFmt       = ( ( re.search("\\x5B(.+?)\\x5D", ans2) or g1z ).group(1) )   ##[] = 0x5B,0x5D
bNoAuthTitile  = ( 1 if ( 1+ans2.find("f") ) else 0 )
##bUndrscDownrn

if bAutoOud:
	print("INFO: Creating output dir.")
	os.mkdir( szOud )

szImfExt = (os.path.splitext(szImf)[1]).strip(".").lower()
szNewFmt = ( szNewFmt if szNewFmt else szImfExt )
aOuFmt   = ( (szNewFmt,szNewFmt,) if (szNewFmt != "mkv") else ("matroska","mkv",) )

for i in range(0, len(tracks3)):
	a = tracks3[i]
	fnm2 = ""
	if( not bNoAuthTitile ):
		ath2 = re.sub("[^a-zA-Z0-9_]+", "_", a["ath"] )
		ttl2 = re.sub("[^a-zA-Z0-9_]+", "_", a["ttl"] )
		fnm2 = re.sub("_{2,}", "_", ("_%s_%s" % (ath2, ttl2,) ).rstrip("_") )[:64]
	szOuFnm  = ("%s/%03d%s.%s" % (szOud, i+1, fnm2, aOuFmt[1],))
	## ffmpeg -ss <secs.f> -t <secs.f> -f <fmt> -c:a copy -c:v copy ...
	len2 = a["len2"]
	cmd2 = ("%s -loglevel 16 -i %s -f %s -c:a copy -c:v copy%s -ss%s%s%s %s" % ( 
				szFfe, ("\x22%s\x22" % szImf ), aOuFmt[0],
				(" -map_metadata -1" if bStripMetadata else "" ),
				(" %f" % a["bgn2"]),
				("" if (not len2) else (" -t %f" % (len2,)) ),
				("" if (not bNoFfmStdou) else (" 2>"+os.devnull) ),
				("\x22%s\x22" % szOuFnm),))
	print("\n"+"CMD: [%s]" % (cmd2,))
	print("%d/%d Running Ffmpeg...\n\n" % (i+1, len(tracks3) ) ),
	rs2 = subprocess.call( cmd2, shell=True )
	if rs2:
		nErr += 1
		print("ERROR: ffmpeg failed (code:%d, nErr:%d)." % (rs2,nErr,))
		if bStopOnFfErr:
			raw_input("Continue...")
	if( bCnfrmWaitNext and (not rs2 or not bStopOnFfErr) ):
		raw_input("Continue...")


print("Done. (errors:%d)." % (nErr,) )










